# Extension: Plan Extension Phases from Comprehensive PRP

## Usage: ext-2-plan-phases [COMPREHENSIVE_PRP_PATH]

Analyzes the comprehensive extension PRP to discover natural phase boundaries based on technical complexity and implementation dependencies. Extracts implementation-driven phase requirements from the complete technical architecture.

## Purpose

This command analyzes the comprehensive PRP's technical architecture to identify optimal phase boundaries based on implementation complexity, dependencies, and integration patterns. It transforms the complete technical understanding into manageable implementation phases that follow natural technical workflows.

## Usage Examples
```bash
/ext-2-plan-phases PRP-EXTENSIONS/EXT_HistoricalDataFoundation/planning/extension-prp-historicaldata-20241215-143022.md
/ext-2-plan-phases ./extension-prp-advancedcharts-20241215-151534.md
/ext-2-plan-phases extension-prp-machinelearning-20241215-094712.md
```

## Prerequisites Validation
Before executing this command, validate that:
- [ ] Comprehensive extension PRP file exists and is readable
- [ ] PRP was generated by /ext-1-generate-prp command
- [ ] PRP contains complete technical architecture and implementation details
- [ ] Extension directory structure exists with planning/ folder
- [ ] TEMPLATE_EXTENSION_PHASE_REQUIREMENTS.md exists in PRP-EXTENSIONS/templates/

## Implementation-Driven Phase Discovery Process

### 1. Technical Architecture Analysis
```bash
# Analyze complete implementation architecture from PRP
- Database schema complexity and migration dependencies
- API endpoint design and integration complexity
- Frontend component architecture and dependencies
- Service layer design and external integration requirements
- Testing strategy complexity and validation requirements
- Deployment and configuration complexity
```

### 2. Dependency Mapping and Complexity Assessment
```bash
# Identify technical dependencies and complexity levels
- Database foundation dependencies (schema, migrations, base models)
- API layer dependencies (endpoints, authentication, validation)
- Service layer dependencies (business logic, external APIs, caching)
- Frontend dependencies (components, state management, routing)
- Integration dependencies (existing system connections)
- Testing dependencies (unit, integration, end-to-end requirements)
```

### 3. Natural Phase Boundary Discovery
```bash
# Discover optimal phase boundaries based on technical workflow
- Foundation Phase: Core data models and minimal integration
- API Integration Phase: Service layer and API endpoint implementation
- UI Implementation Phase: Frontend components and user workflows  
- Integration & Optimization Phase: System integration and performance
```

### 4. Implementation Complexity Distribution
```bash
# Distribute implementation work across phases based on complexity
- Balance implementation effort across phases
- Ensure each phase delivers working functionality
- Minimize cross-phase dependencies and integration risks
- Plan for incremental testing and validation
```

## Phase Requirements Extraction Process

### 1. PRP Architecture Decomposition
```bash
# Break down comprehensive PRP into phase-specific requirements
- Extract database requirements for each phase
- Extract API requirements for each phase  
- Extract frontend requirements for each phase
- Extract service layer requirements for each phase
- Extract testing requirements for each phase
- Extract integration requirements for each phase
```

### 2. Phase-Specific Implementation Planning
```bash
# Create detailed phase implementation plans
- Map PRP technical architecture to phase deliverables
- Extract phase-specific integration points from comprehensive plan
- Identify phase dependencies on previous phases
- Plan phase validation and completion criteria
```

### 3. Technical Dependency Chain Creation
```bash
# Establish clear dependencies between phases
- Phase 1 outputs that Phase 2 depends on
- Phase 2 outputs that Phase 3 depends on
- Integration points available after each phase completion
- Rollback strategies for each phase boundary
```

## Generated Phase Files Structure

### Extension Phase Plan
- **EXTENSION_PHASE_PLAN.md**: Implementation-driven phase strategy including:
  - Technical complexity analysis from comprehensive PRP
  - Natural phase boundaries based on implementation workflow
  - Phase dependencies and integration strategy
  - Implementation effort distribution and timeline estimates

### Phase Requirements (Extracted from Comprehensive PRP)
- **PHASE1_REQUIREMENTS.md**: Foundation phase requirements including:
  - Database models and schema extracted from comprehensive design
  - Core services extracted from complete service architecture
  - Minimal API endpoints from complete API design
  - Basic testing requirements from comprehensive test strategy

- **PHASE2_REQUIREMENTS.md**: Integration phase requirements including:
  - API layer implementation from comprehensive design
  - Service integration from complete architecture
  - Authentication and validation from comprehensive plan
  - Integration testing from complete test strategy

- **PHASE3_REQUIREMENTS.md**: UI implementation phase requirements including:
  - Frontend components from comprehensive UI architecture
  - User workflows from complete workflow design
  - State management from comprehensive frontend plan
  - UI testing from complete test strategy

- **PHASE4_REQUIREMENTS.md**: Optimization phase requirements including:
  - Performance optimization from comprehensive plan
  - System integration from complete integration strategy
  - Production readiness from comprehensive deployment plan
  - End-to-end testing from complete validation strategy

## Technical Architecture Mapping

### Database Architecture Phase Distribution
```markdown
Phase 1 (Foundation):
- Core data models and relationships
- Database migrations and schema creation
- Basic data access patterns

Phase 2 (Integration):
- Advanced relationships and constraints
- Data validation and business rules
- Query optimization and indexing

Phase 3 (UI Implementation):
- Data serialization for frontend
- Search and filtering requirements
- Data export and import capabilities

Phase 4 (Optimization):
- Performance optimization and caching
- Data archiving and maintenance
- Backup and recovery procedures
```

### API Architecture Phase Distribution
```markdown
Phase 1 (Foundation):
- Core data access endpoints
- Basic CRUD operations
- Authentication framework

Phase 2 (Integration):
- Business logic endpoints
- Integration with existing APIs
- Advanced validation and error handling

Phase 3 (UI Implementation):
- UI-specific endpoints and data formats
- Real-time updates and WebSocket integration
- Search and filtering endpoints

Phase 4 (Optimization):
- Performance optimization and caching
- Rate limiting and security hardening
- API documentation and monitoring
```

### Frontend Architecture Phase Distribution
```markdown
Phase 1 (Foundation):
- Basic component structure
- State management setup
- Navigation and routing foundation

Phase 2 (Integration):
- API integration and data fetching
- Error handling and loading states
- Form validation and submission

Phase 3 (UI Implementation):
- Complete user interface implementation
- Advanced interactions and workflows
- Real-time updates and notifications

Phase 4 (Optimization):
- Performance optimization and lazy loading
- Accessibility and mobile responsiveness
- Testing and browser compatibility
```

## Output File Organization

### Directory Structure Update
```bash
# Phase planning adds to existing extension structure:
PRP-EXTENSIONS/EXT_[ExtensionName]/
├── planning/
│   ├── EXTENSION_BRD.md
│   ├── extension-prp-[timestamp].md (from ext-1-generate-prp)
│   ├── EXTENSION_PHASE_PLAN.md (generated)
│   └── EXTENSION_CONFIG.yaml (updated)
└── phases/
    ├── PHASE1_REQUIREMENTS.md (extracted from PRP)
    ├── PHASE2_REQUIREMENTS.md (extracted from PRP)
    ├── PHASE3_REQUIREMENTS.md (extracted from PRP)
    └── PHASE4_REQUIREMENTS.md (extracted from PRP)
```

### Phase Naming and Numbering
```bash
# Phase files follow implementation-driven naming:
PHASE1_REQUIREMENTS.md - Foundation (Database & Core Services)
PHASE2_REQUIREMENTS.md - API Integration (Endpoints & Business Logic)
PHASE3_REQUIREMENTS.md - UI Implementation (Components & Workflows)
PHASE4_REQUIREMENTS.md - Optimization (Performance & Integration)
```

## Command Execution Flow

### Step 1: Comprehensive PRP Analysis
- Read and parse the comprehensive extension PRP
- Extract complete technical architecture and implementation details
- Analyze implementation complexity and dependencies
- Identify natural technical workflow patterns

### Step 2: Phase Boundary Discovery
- Analyze technical dependencies to discover natural break points
- Assess implementation complexity distribution opportunities
- Identify deliverable milestones that provide value
- Plan incremental integration and testing strategies

### Step 3: Phase Requirements Extraction
- Extract phase-specific requirements from comprehensive PRP
- Map complete technical architecture to phase deliverables
- Create phase dependency chains and integration points
- Plan phase validation and completion criteria

### Step 4: File Generation and Validation
- Generate EXTENSION_PHASE_PLAN.md with implementation-driven strategy
- Create individual PHASE[N]_REQUIREMENTS.md files with extracted requirements
- Update EXTENSION_CONFIG.yaml with phase information
- Validate phase plan for completeness and technical feasibility

## Integration with Extension Workflow

This command extracts implementation-driven phases from comprehensive understanding:

**Prerequisites**: 
- `/ext-0-analyze-codebase [PATH]` - Codebase understanding
- `/ext-1-generate-prp [EXTENSION_NAME] [BRD]` - Comprehensive PRP

**Current Step**: `/ext-2-plan-phases [PRP_PATH]` - Discover natural phase boundaries
**Next Step**: `/ext-3-execute-prp [PRP_PATH] --phase [N]` - Execute specific phase

## Success Metrics

Successful implementation-driven phase planning should produce:
- **Natural Phase Boundaries**: Phases follow technical implementation workflow
- **Technical Dependency Alignment**: Phase sequence matches implementation dependencies  
- **Balanced Complexity**: Each phase has manageable and similar implementation effort
- **Incremental Value**: Each phase delivers working functionality that can be tested
- **Integration-Ready**: Phase boundaries enable clean integration and testing

The resulting phase plan should reflect the technical reality of implementation while providing manageable development milestones that align with natural technical workflows.